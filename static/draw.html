<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<title>DrawIt Canvas</title>
	<link rel="stylesheet" href="/static/draw.css">
</head>


<body class="mode-drawing">

	<div class="ui-layer">

		<div id="colorMenuBtn" class="colorbtn"></div>
		<div id="colorOverlay" class="overlay">
			<div id="colorGrid" class="color-grid"></div>
		</div>
		
		<div id="radiusTools" class="ui-element" title="Choose pen radius">
			<input type="number" id="radiusPicker" min="1" max="40" value="1">
		</div>
		<div id="usersCount" class="ui-element" title="Users connected">
			<p id="count">5</p>
		</div>

	</div>


	<div id="viewport">
		<div id="canvas-container">
			<div>
				<canvas id="back" width="1920" height="1080"></canvas>
			</div>
			<div>
				<canvas id="top"  width="1920" height="1080"></canvas>
			</div>
		</div>
	</div>


	<script type="module" src="/static/draw.js"></script>
	<script type="module">
		import { setupWebsocket } from "/static/websockets.js";
		import { DrawingModule } from '/static/draw.js';
		import { Event, DrawingEventType } from "/static/events.js"
		import { Map } from "/static/map.js"
		const isDraw = window.location.pathname == "/draw"

		const drawingModuleInstance = new DrawingModule("back");
		const map = new Map("top");
		//colors of the palette !
		let selectedColor = drawingModuleInstance.palette[0];//base color
		colorMenuBtn.style.backgroundColor = selectedColor; //set the initial color of the background button
		colorMenuBtn.style.border = "1px solid #000000";
		colorOverlay.style.display = 'none';
		// Create color swatches
		drawingModuleInstance.palette.forEach(hex => {
			const swatch = document.createElement('div');
			swatch.classList.add("color-swatch");
			swatch.style.backgroundColor = hex;
			swatch.addEventListener('click', () => {
				selectedColor = hex;
				colorMenuBtn.style.backgroundColor = hex;
				colorOverlay.style.display = 'none';
				// update your drawing module
				if (drawingModuleInstance) {
					drawingModuleInstance.currentColor = drawingModuleInstance.hexToRgbObject(selectedColor);
				}
			});
			document.getElementById("colorGrid").appendChild(swatch);
		});

		let sleep = () => {};
		if (document.location.href.includes("rewind")) {
			sleep = (ms) => {
			    return new Promise(resolve => setTimeout(resolve, ms));
			}		
		}

		let count = 0;
		const countElem = document.getElementById("count")
		const sendMessage = await setupWebsocket(async (d) => {
		  const events = Event.deserialize_list(await d.arrayBuffer());
			for (let event of events) {
				await sleep(1)
				if (event.type == DrawingEventType.USER_CONNECTED) {
					count+=1;
					countElem.innerHTML = count;
				}
				if (event.type == DrawingEventType.USER_DISCONNECTED) {
					count-=1;
					countElem.innerHTML = count;
				}
				if (event.type == DrawingEventType.ADD_ZONE) {
					map.zones.push(event);
					map.redraw();
				} else {
				drawingModuleInstance.HandleEvent(event);
				
				}
				
			}

	  });

		if (isDraw) {
			document.getElementById("top").style.pointerEvents = "none";
			drawingModuleInstance.listen(sendMessage);
		}

		if (!isDraw) {
			map.setupHandlers();
		}


		class MovablePan {
    constructor(id) {
        this.e = document.getElementById(id);
        this.scale = 1;
        this.offsetX = 0;
        this.offsetY = 0;

        this.activeTouches = [];
        this.startOffsetX = 0;
        this.startOffsetY = 0;
        this.startDistance = 0;
        this.startScale = 1;
        this.startMidpoint = { x: 0, y: 0 };

        this.initEvents();
        this.transform();
    }

    transform() {
        this.e.style.transformOrigin = `0 0`;
        this.e.style.transform = `translate(${this.offsetX}px, ${this.offsetY}px) scale(${this.scale})`;
    }

    getDistance(touches) {
        const dx = touches[0].clientX - touches[1].clientX;
        const dy = touches[0].clientY - touches[1].clientY;
        return Math.sqrt(dx * dx + dy * dy);
    }

    getMidpoint(touches) {
        return {
            x: (touches[0].clientX + touches[1].clientX) / 2,
            y: (touches[0].clientY + touches[1].clientY) / 2
        };
    }

    initEvents() {
        // Track touches globally
        window.addEventListener("touchstart", (e) => {
            if (e.touches.length >= 2) {
                this.activeTouches = [e.touches[0], e.touches[1]];
                this.startOffsetX = this.offsetX;
                this.startOffsetY = this.offsetY;
                this.startDistance = this.getDistance(this.activeTouches);
                this.startScale = this.scale;
                this.startMidpoint = this.getMidpoint(this.activeTouches);
            }
        }, { passive: false });

        window.addEventListener("touchmove", (e) => {
            if (this.activeTouches.length === 2 && e.touches.length >= 2) {
								e.preventDefault()
                // Find the two touches we are tracking
                const touches = [e.touches[0], e.touches[1]];

                const newDistance = this.getDistance(touches);
                const newScale = this.startScale * (newDistance / this.startDistance);

                const newMidpoint = this.getMidpoint(touches);

                // Movement proportional to scale
                const dx = (newMidpoint.x - this.startMidpoint.x) / newScale;
                const dy = (newMidpoint.y - this.startMidpoint.y) / newScale;

                // Apply proportional movement and scaling
                this.offsetX = (this.startOffsetX + dx) * (newScale / this.startScale);
                this.offsetY = (this.startOffsetY + dy) * (newScale / this.startScale);

                this.scale = newScale;
                this.transform();
            }
        }, { passive: false });

        window.addEventListener("touchend", (e) => {
            if (e.touches.length < 2) {
                this.activeTouches = [];
            }
        });
    }
}

// Initialize
const mp = new MovablePan("canvas-container");

		

	</script>

</body>

</html>
