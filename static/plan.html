<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<title>Zone Creator</title>
	<link rel="stylesheet" href="plan.css">
</head>

<body class="mode-drawing">

	<div class="ui-layer">
		<div id="zoneTools" class="ui-element">
			<input type="text" id="zoneNameInput" placeholder="Enter Zone Description..." value="">
		</div>

		<div id="modeSwitch" class="ui-element" onclick="toggleMode()">
			Switch to View
		</div>
	</div>

	<div class="status-bar" id="statusBar">Creation Mode: Enter name, then drag to create</div>

	<div id="viewport">
		<div id="canvas-container">
			<div class="canvas-label">Zone Admin</div>
			<canvas id="mainCanvas" width="2000" height="2000"></canvas>
		</div>
	</div>

	<script>
		// --- State Management ---
		const state = {
			mode: 'drawing', // 'drawing' or 'view'
			scale: 1,
			pointX: 0,
			pointY: 0,
			panning: false,
			panStartX: 0,
			panStartY: 0,
			isDraggingZone: false,
			zoneStartX: 0,
			zoneStartY: 0,
			currentMouseX: 0,
			currentMouseY: 0,
			zones: [],
			minScale: 0.2,
			maxScale: 4,
			canvasWidth: 2000,
			canvasHeight: 2000
		};

		// --- Elements ---
		const body = document.body;
		const modeBtn = document.getElementById('modeSwitch');
		const statusBar = document.getElementById('statusBar');
		const container = document.getElementById('canvas-container');
		const viewport = document.getElementById('viewport');
		const canvas = document.getElementById('mainCanvas');
		const ctx = canvas.getContext('2d');
		const zoneInput = document.getElementById('zoneNameInput');

		// --- Initialization ---
		state.pointX = (window.innerWidth - state.canvasWidth) / 2;
		state.pointY = (window.innerHeight - state.canvasHeight) / 2;
		updateTransform();
		redrawCanvas();

		// --- Logic ---

		function toggleMode() {
			if (state.mode === 'drawing') {
				state.mode = 'view';
				body.classList.remove('mode-drawing');
				body.classList.add('mode-view');
				modeBtn.innerText = "Switch to Create";
				statusBar.innerText = "View Mode: Click zones to see info";
				// Clear error states when switching
				zoneInput.classList.remove('input-error');
			} else {
				state.mode = 'drawing';
				body.classList.remove('mode-view');
				body.classList.add('mode-drawing');
				modeBtn.innerText = "Switch to View";
				statusBar.innerText = "Creation Mode: Enter name, then drag to create";
			}
		}

		function updateTransform() {
			container.style.transform = `translate(${state.pointX}px, ${state.pointY}px) scale(${state.scale})`;
		}

		function getCanvasCoordinates(clientX, clientY) {
			return {
				x: (clientX - state.pointX) / state.scale,
				y: (clientY - state.pointY) / state.scale
			};
		}

		// --- Rendering ---
		function redrawCanvas() {
			ctx.clearRect(0, 0, state.canvasWidth, state.canvasHeight);

			// Saved Zones
			state.zones.forEach(zone => {
				ctx.fillStyle = "rgba(37, 99, 235, 0.15)";
				ctx.fillRect(zone.x, zone.y, zone.w, zone.h);
				ctx.strokeStyle = "#2563eb";
				ctx.lineWidth = 2;
				ctx.setLineDash([]);
				ctx.strokeRect(zone.x, zone.y, zone.w, zone.h);

				// Draw truncated label
				ctx.fillStyle = "#2563eb";
				ctx.font = "bold 14px sans-serif";
				let label = zone.desc;
				if (label.length > 15) label = label.substring(0, 15) + "...";
				ctx.fillText(label, zone.x + 5, zone.y + 20);
			});

			// Active Drag
			if (state.mode === 'drawing' && state.isDraggingZone) {
				const width = state.currentMouseX - state.zoneStartX;
				const height = state.currentMouseY - state.zoneStartY;

				ctx.fillStyle = "rgba(37, 99, 235, 0.05)";
				ctx.fillRect(state.zoneStartX, state.zoneStartY, width, height);
				ctx.strokeStyle = "#2563eb";
				ctx.lineWidth = 2;
				ctx.setLineDash([10, 5]);
				ctx.strokeRect(state.zoneStartX, state.zoneStartY, width, height);
			}
		}

		// --- Event Listeners ---

		viewport.addEventListener('mousedown', (e) => {
			const coords = getCanvasCoordinates(e.clientX, e.clientY);

			if (state.mode === 'view') {
				state.panning = true;
				state.panStartX = e.clientX - state.pointX;
				state.panStartY = e.clientY - state.pointY;
			}
			else if (state.mode === 'drawing') {
				// VALIDATION CHECK:
				const desc = zoneInput.value.trim();

				if (!desc) {
					// 1. Highlight the input box
					zoneInput.classList.add('input-error');
					zoneInput.focus();

					// 2. Highlight the Status Bar
					statusBar.innerText = "Error: You must enter a description first!";
					statusBar.classList.add('error');

					// 3. Reset highlights after a delay
					setTimeout(() => {
						zoneInput.classList.remove('input-error');
						statusBar.classList.remove('error');
						statusBar.innerText = "Creation Mode: Enter name, then drag to create";
					}, 1500);

					return; // STOP here, do not start dragging
				}

				// If valid, proceed
				state.isDraggingZone = true;
				state.zoneStartX = coords.x;
				state.zoneStartY = coords.y;
				state.currentMouseX = coords.x;
				state.currentMouseY = coords.y;
			}
		});

		window.addEventListener('mousemove', (e) => {
			const coords = getCanvasCoordinates(e.clientX, e.clientY);

			if (state.mode === 'view' && state.panning) {
				e.preventDefault();
				let rawX = e.clientX - state.panStartX;
				let rawY = e.clientY - state.panStartY;
				const clamped = clampPosition(rawX, rawY, state.scale);
				state.pointX = clamped.x;
				state.pointY = clamped.y;
				updateTransform();
			}
			else if (state.mode === 'drawing' && state.isDraggingZone) {
				state.currentMouseX = coords.x;
				state.currentMouseY = coords.y;
				redrawCanvas();
			}
		});

		window.addEventListener('mouseup', (e) => {
			if (state.mode === 'view') {
				state.panning = false;
			}
			else if (state.mode === 'drawing' && state.isDraggingZone) {
				state.isDraggingZone = false;

				const w = state.currentMouseX - state.zoneStartX;
				const h = state.currentMouseY - state.zoneStartY;

				if (Math.abs(w) > 10 && Math.abs(h) > 10) {
					const newZone = {
						x: w < 0 ? state.zoneStartX + w : state.zoneStartX,
						y: h < 0 ? state.zoneStartY + h : state.zoneStartY,
						w: Math.abs(w),
						h: Math.abs(h),
						desc: zoneInput.value.trim() // Guaranteed to exist due to mousedown check
					};

					state.zones.push(newZone);
					statusBar.innerText = `Zone Created: "${newZone.desc}"`;

					// Clear input for next one (optional - keeping it allows rapid creation of same type)
					// zoneInput.value = ""; 

					statusBar.classList.add('highlight');
					setTimeout(() => statusBar.classList.remove('highlight'), 300);
				}
				redrawCanvas();
			}
		});

		viewport.addEventListener('click', (e) => {
			if (state.mode !== 'view') return;

			const coords = getCanvasCoordinates(e.clientX, e.clientY);

			const clickedZone = [...state.zones].reverse().find(z =>
				coords.x >= z.x && coords.x <= z.x + z.w &&
				coords.y >= z.y && coords.y <= z.y + z.h
			);

			if (clickedZone) {
				statusBar.innerText = `Selected Zone: ${clickedZone.desc}`;
				statusBar.classList.add('highlight');
				setTimeout(() => statusBar.classList.remove('highlight'), 300);
			} else {
				statusBar.innerText = "View Mode: Click zones to see info";
			}
		});

		viewport.addEventListener('wheel', (e) => {
			e.preventDefault();
			const zoomSensitivity = 0.001;
			const delta = -e.deltaY * zoomSensitivity;
			const oldScale = state.scale;
			let newScale = Math.min(Math.max(oldScale + delta, state.minScale), state.maxScale);

			const rect = viewport.getBoundingClientRect();
			const mouseX = e.clientX - rect.left;
			const mouseY = e.clientY - rect.top;

			const worldX = (mouseX - state.pointX) / oldScale;
			const worldY = (mouseY - state.pointY) / oldScale;

			let newPointX = mouseX - (worldX * newScale);
			let newPointY = mouseY - (worldY * newScale);

			const clamped = clampPosition(newPointX, newPointY, newScale);
			state.scale = newScale;
			state.pointX = clamped.x;
			state.pointY = clamped.y;
			updateTransform();
		}, {passive: false});

		function clampPosition(x, y, scale) {
			const viewportW = viewport.clientWidth;
			const viewportH = viewport.clientHeight;
			const minX = viewportW - (state.canvasWidth * scale);
			const minY = viewportH - (state.canvasHeight * scale);
			let newX = x;
			let newY = y;

			if (newX > 0) newX = 0;
			if (newY > 0) newY = 0;
			if (newX < minX) newX = minX;
			if (newY < minY) newY = minY;

			if (state.canvasWidth * scale < viewportW) newX = (viewportW - state.canvasWidth * scale) / 2;
			if (state.canvasHeight * scale < viewportH) newY = (viewportH - state.canvasHeight * scale) / 2;

			return {x: newX, y: newY};
		}

	</script>
</body>

</html>